<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Initiation Test - Neon Serpents</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">
    <style>
        /* ========== BASE RESET & FONTS ========== */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', Courier, monospace;
            background: linear-gradient(135deg, #0a0015 0%, #1a0033 50%, #000000 100%);
            color: #00ffff;
            min-height: 100vh;
            overflow-x: hidden;
        }

        /* ========== SCANLINE OVERLAY ========== */
        body::before {
            content: "";
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: repeating-linear-gradient(
                0deg,
                rgba(0, 255, 255, 0.03),
                rgba(0, 255, 255, 0.03) 1px,
                transparent 1px,
                transparent 2px
            );
            pointer-events: none;
            z-index: 1000;
        }

        /* ========== HEADER ========== */
        header {
            padding: 1.5rem 2rem;
            border-bottom: 2px solid #ff00ff;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .logo {
            font-family: 'Orbitron', sans-serif;
            font-size: 1.5rem;
            color: #ff00ff;
            text-shadow: 0 0 10px #ff00ff;
        }

        .breadcrumb {
            color: #00ffff;
            font-size: 1rem;
        }

        /* ========== MAIN CONTAINER ========== */
        .container {
            max-width: 1400px;
            margin: 2rem auto;
            padding: 0 2rem;
            display: grid;
            grid-template-columns: 300px 1fr;
            gap: 3rem;
            position: relative;
            z-index: 1;
        }

        @media (max-width: 968px) {
            .container {
                grid-template-columns: 1fr;
                gap: 2rem;
            }
        }

        /* ========== LEFT COLUMN: INSTRUCTIONS ========== */
        .instructions {
            background: rgba(30, 30, 35, 0.8);
            border: 2px solid #00ffff;
            border-radius: 8px;
            padding: 2rem;
            height: fit-content;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
        }

        .instructions h2 {
            color: #ff00ff;
            margin-bottom: 1rem;
            font-size: 1.3rem;
            text-shadow: 0 0 10px #ff00ff;
        }

        .instructions p {
            font-size: 0.9rem;
            line-height: 1.6;
            margin-bottom: 1rem;
            color: #00ffff;
        }

        .progress-section {
            margin-top: 2rem;
        }

        .progress-label {
            color: #ff00ff;
            font-size: 0.9rem;
            margin-bottom: 0.5rem;
            display: block;
        }

        .progress-bar {
            width: 100%;
            height: 20px;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid #00ffff;
            border-radius: 4px;
            overflow: hidden;
            position: relative;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #00ffff, #ff00ff);
            width: 0%;
            transition: width 0.5s ease;
            box-shadow: 0 0 10px #00ffff;
        }

        .progress-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 0.75rem;
            font-weight: bold;
            color: #fff;
            text-shadow: 0 0 5px #000;
        }

        /* ========== RIGHT COLUMN: QUESTION CARD ========== */
        .question-area {
            background: rgba(30, 30, 35, 0.9);
            border: 2px solid #ff00ff;
            border-radius: 12px;
            padding: 3rem;
            min-height: 500px;
            box-shadow: 0 0 30px rgba(255, 0, 102, 0.3);
            position: relative;
            animation: cardFlip 0.6s ease-out;
        }

        @keyframes cardFlip {
            0% {
                transform: rotateY(90deg);
                opacity: 0;
            }
            100% {
                transform: rotateY(0);
                opacity: 1;
            }
        }

        .question-card h3 {
            color: #ff00ff;
            font-size: 1.8rem;
            margin-bottom: 1.5rem;
            text-shadow: 0 0 10px #ff00ff;
        }

        .question-text {
            font-size: 1.2rem;
            color: #00ffff;
            margin-bottom: 2rem;
            line-height: 1.6;
        }

        .choices {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .choice-btn {
            background: rgba(0, 255, 255, 0.1);
            border: 2px solid #00ffff;
            color: #00ffff;
            padding: 1rem 1.5rem;
            font-size: 1rem;
            font-family: 'Courier New', Courier, monospace;
            cursor: pointer;
            border-radius: 6px;
            transition: all 0.3s ease;
            text-align: left;
        }

        .choice-btn:hover {
            background: rgba(0, 255, 255, 0.2);
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.5);
            transform: translateX(5px);
        }

        .choice-btn.selected {
            background: rgba(255, 0, 102, 0.3);
            border-color: #ff00ff;
            color: #ff00ff;
            box-shadow: 0 0 20px rgba(255, 0, 102, 0.6);
        }

        /* Puzzle specific styles */
        .puzzle-area {
            display: flex;
            justify-content: center;
            gap: 2rem;
            margin: 2rem 0;
        }

        .puzzle-icon {
            width: 80px;
            height: 80px;
            border: 2px solid #00ffff;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2rem;
            cursor: pointer;
            background: rgba(0, 255, 255, 0.1);
            transition: all 0.3s ease;
            user-select: none;
        }

        .puzzle-icon:hover {
            transform: scale(1.1);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.6);
        }

        .puzzle-icon.active {
            border-color: #ff00ff;
            box-shadow: 0 0 20px rgba(255, 0, 102, 0.6);
        }

        /* ========== FOOTER BUTTONS ========== */
        footer {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(0, 0, 0, 0.8);
            border-top: 2px solid #ff00ff;
            padding: 1.5rem 2rem;
            display: flex;
            justify-content: center;
            gap: 2rem;
            z-index: 100;
        }

        .btn {
            padding: 1rem 2rem;
            font-size: 1rem;
            font-family: 'Courier New', Courier, monospace;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            border: 2px solid;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s ease;
            background: transparent;
        }

        .btn-primary {
            color: #00ffff;
            border-color: #00ffff;
        }

        .btn-primary:hover:not(:disabled) {
            background: #00ffff;
            color: #000;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.6);
        }

        .btn-secondary {
            color: #999;
            border-color: #666;
        }

        .btn-secondary:hover {
            border-color: #00ffff;
            color: #00ffff;
        }

        .btn-danger {
            color: #ff0066;
            border-color: #ff0066;
        }

        .btn-danger:hover {
            background: #ff0066;
            color: #000;
            box-shadow: 0 0 20px rgba(255, 0, 102, 0.6);
        }

        .btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        /* ========== MODAL (ROLE REVEAL) ========== */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 2000;
            justify-content: center;
            align-items: center;
        }

        .modal.active {
            display: flex;
            animation: fadeIn 0.5s ease-out;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .modal-content {
            background: linear-gradient(135deg, rgba(30, 30, 35, 0.95), rgba(15, 15, 20, 0.98));
            border: 3px solid #ff00ff;
            border-radius: 12px;
            padding: 3rem;
            max-width: 600px;
            text-align: center;
            box-shadow: 0 0 50px rgba(255, 0, 102, 0.8);
            animation: modalSlide 0.6s ease-out;
        }

        @keyframes modalSlide {
            from {
                transform: translateY(-100px) scale(0.8);
                opacity: 0;
            }
            to {
                transform: translateY(0) scale(1);
                opacity: 1;
            }
        }

        .role-icon {
            font-size: 5rem;
            margin-bottom: 1rem;
            animation: glitchIcon 2s infinite;
        }

        @keyframes glitchIcon {
            0%, 90%, 92%, 94%, 96%, 98%, 100% {
                transform: translate(0);
                filter: hue-rotate(0deg);
            }
            91% {
                transform: translate(-3px, 3px);
                filter: hue-rotate(90deg);
            }
            93% {
                transform: translate(3px, -3px);
                filter: hue-rotate(180deg);
            }
            95% {
                transform: translate(-2px, -2px);
                filter: hue-rotate(270deg);
            }
            97% {
                transform: translate(2px, 2px);
                filter: hue-rotate(45deg);
            }
        }

        .role-title {
            font-family: 'Orbitron', sans-serif;
            font-size: 2.5rem;
            color: #ff00ff;
            margin-bottom: 1rem;
            text-shadow: 0 0 20px #ff00ff, 0 0 40px #ff00ff;
        }

        .role-description {
            color: #00ffff;
            font-size: 1.1rem;
            line-height: 1.8;
            margin-bottom: 2rem;
        }

        .modal-buttons {
            display: flex;
            gap: 1rem;
            justify-content: center;
        }

        .hidden {
            display: none;
        }
    </style>
</head>
<body>
    <!-- Header -->
    <header>
        <div class="logo">NEON SERPENTS</div>
        <div class="breadcrumb">Initiation Test</div>
    </header>

    <!-- Main Container -->
    <div class="container">
        <!-- Left Column: Instructions & Progress -->
        <aside class="instructions">
            <h2>Test Protocol</h2>
            <p>You will face 4 situational challenges. Your choices determine your operational role.</p>
            <p>Answer honestly. There are no wrong answers, only assignments.</p>
            <p><strong>Roles:</strong></p>
            <ul style="font-size: 0.85rem; line-height: 1.6; color: #999; margin-left: 1.2rem;">
                <li>Ghost (Stealth)</li>
                <li>Venom (Data Manipulation)</li>
                <li>Prophet (Strategic Vision)</li>
            </ul>

            <div class="progress-section">
                <span class="progress-label">Progress</span>
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill"></div>
                    <span class="progress-text" id="progressText">0 / 4</span>
                </div>
            </div>
        </aside>

        <!-- Right Column: Question Card -->
        <main class="question-area" id="questionArea">
            <div class="question-card" id="questionCard">
                <!-- Questions will be injected here by JS -->
            </div>
        </main>
    </div>

    <!-- Footer Buttons -->
    <footer>
        <button class="btn btn-secondary" id="skipBtn">Skip</button>
        <button class="btn btn-primary" id="submitBtn" disabled>Submit Answer</button>
        <button class="btn btn-danger" id="abortBtn">Abort Test</button>
    </footer>

    <!-- Role Reveal Modal -->
    <div class="modal" id="roleModal">
        <div class="modal-content">
            <div class="role-icon" id="roleIcon">üëÅÔ∏è</div>
            <h2 class="role-title" id="roleTitle">GHOST</h2>
            <p class="role-description" id="roleDescription">
                You move through shadows unseen. Your specialty is stealth, evasion, and silent extraction.
            </p>
            <div class="modal-buttons">
                <button class="btn btn-primary" id="acceptRoleBtn">Accept Role</button>
                <button class="btn btn-secondary" id="retryBtn">Retry Test</button>
            </div>
        </div>
    </div>

    <script>
        // ========== QUESTIONS DATABASE ==========
        const questions = [
            {
                id: 1,
                type: 'choice',
                question: 'You find an access node with an old encryption key. Do you:',
                choices: [
                    { text: 'A) Copy it and vanish', role: 'ghost', weight: 3 },
                    { text: 'B) Try to crack it publicly', role: 'venom', weight: 3 },
                    { text: 'C) Sell it to a broker', role: 'prophet', weight: 3 }
                ]
            },
            {
                id: 2,
                type: 'choice',
                question: 'During a run you are detected. Do you:',
                choices: [
                    { text: 'A) Delete traces and run', role: 'ghost', weight: 3 },
                    { text: 'B) Upload false logs to misdirect', role: 'venom', weight: 3 },
                    { text: 'C) Hold ground and dump the payload', role: 'prophet', weight: 3 }
                ]
            },
            {
                id: 3,
                type: 'puzzle',
                question: 'Decrypt the sequence. Arrange these symbols in correct order: üîí ‚Üí üîë ‚Üí üíæ',
                correctOrder: ['üîí', 'üîë', 'üíæ'],
                icons: ['üíæ', 'üîë', 'üîí'] // Scrambled
            },
            {
                id: 4,
                type: 'choice',
                question: 'You can leak one corporate secret to save a neighborhood. Do you:',
                choices: [
                    { text: 'A) Leak now', role: 'venom', weight: 3 },
                    { text: 'B) Wait for better leverage', role: 'prophet', weight: 3 },
                    { text: 'C) Refuse (moral stance)', role: 'ghost', weight: 3 }
                ]
            }
        ];

        // ========== STATE MANAGEMENT ==========
        let currentQuestionIndex = 0;
        let answers = JSON.parse(localStorage.getItem('initiationAnswers')) || [];
        let scores = { ghost: 0, venom: 0, prophet: 0 };

        // ========== DOM ELEMENTS ==========
        const questionCard = document.getElementById('questionCard');
        const submitBtn = document.getElementById('submitBtn');
        const skipBtn = document.getElementById('skipBtn');
        const abortBtn = document.getElementById('abortBtn');
        const progressFill = document.getElementById('progressFill');
        const progressText = document.getElementById('progressText');
        const roleModal = document.getElementById('roleModal');
        const roleIcon = document.getElementById('roleIcon');
        const roleTitle = document.getElementById('roleTitle');
        const roleDescription = document.getElementById('roleDescription');
        const acceptRoleBtn = document.getElementById('acceptRoleBtn');
        const retryBtn = document.getElementById('retryBtn');

        // ========== ROLE DEFINITIONS ==========
        const roles = {
            ghost: {
                title: 'GHOST',
                icon: 'üëÅÔ∏è',
                description: 'You move through shadows unseen. Your specialty is stealth, evasion, and silent extraction. The network never knows you were there.'
            },
            venom: {
                title: 'VENOM',
                icon: 'üêç',
                description: 'You manipulate data like poison through veins. Misinformation, corruption, and chaos are your tools. The truth bends to your will.'
            },
            prophet: {
                title: 'PROPHET',
                icon: 'üîÆ',
                description: 'You see patterns others miss. Strategic vision and calculated sacrifice define you. You play the long game, and the grid remembers.'
            }
        };

        // ========== RENDER QUESTION ==========
        function renderQuestion(index) {
            const question = questions[index];
            questionCard.innerHTML = '';

            // Add question number and text
            const questionTitle = document.createElement('h3');
            questionTitle.textContent = `Question ${index + 1}`;
            questionCard.appendChild(questionTitle);

            const questionText = document.createElement('p');
            questionText.className = 'question-text';
            questionText.textContent = question.question;
            questionCard.appendChild(questionText);

            // Render based on question type
            if (question.type === 'choice') {
                renderChoiceQuestion(question, index);
            } else if (question.type === 'puzzle') {
                renderPuzzleQuestion(question, index);
            }

            // Update progress
            updateProgress();

            // Trigger card flip animation
            const questionArea = document.getElementById('questionArea');
            questionArea.style.animation = 'none';
            setTimeout(() => {
                questionArea.style.animation = 'cardFlip 0.6s ease-out';
            }, 10);
        }

        // ========== RENDER CHOICE QUESTION ==========
        function renderChoiceQuestion(question, index) {
            const choicesDiv = document.createElement('div');
            choicesDiv.className = 'choices';

            question.choices.forEach((choice, choiceIndex) => {
                const btn = document.createElement('button');
                btn.className = 'choice-btn';
                btn.textContent = choice.text;
                btn.setAttribute('role', 'radio');
                btn.setAttribute('aria-checked', 'false');

                // Check if previously selected
                if (answers[index] === choiceIndex) {
                    btn.classList.add('selected');
                    btn.setAttribute('aria-checked', 'true');
                    submitBtn.disabled = false;
                }

                btn.onclick = () => selectChoice(choiceIndex, question.choices);
                choicesDiv.appendChild(btn);
            });

            questionCard.appendChild(choicesDiv);
        }

        // ========== RENDER PUZZLE QUESTION ==========
        function renderPuzzleQuestion(question, index) {
            const puzzleDiv = document.createElement('div');
            puzzleDiv.className = 'puzzle-area';
            puzzleDiv.id = 'puzzleArea';

            // Use saved order or scrambled default
            let currentOrder = answers[index] || [...question.icons];

            currentOrder.forEach((icon, iconIndex) => {
                const iconDiv = document.createElement('div');
                iconDiv.className = 'puzzle-icon';
                iconDiv.textContent = icon;
                iconDiv.setAttribute('data-index', iconIndex);
                iconDiv.setAttribute('role', 'button');
                iconDiv.setAttribute('aria-label', `Symbol ${iconIndex + 1}`);
                iconDiv.onclick = () => cyclePuzzleIcon(iconIndex, currentOrder, question);
                puzzleDiv.appendChild(iconDiv);
            });

            questionCard.appendChild(puzzleDiv);

            const hint = document.createElement('p');
            hint.style.fontSize = '0.9rem';
            hint.style.color = '#999';
            hint.style.marginTop = '1rem';
            hint.textContent = 'Click icons to cycle through symbols. Find the correct sequence.';
            questionCard.appendChild(hint);

            // Check if already solved
            if (JSON.stringify(currentOrder) === JSON.stringify(question.correctOrder)) {
                submitBtn.disabled = false;
            }
        }

        // ========== HANDLE CHOICE SELECTION ==========
        function selectChoice(choiceIndex, choices) {
            // Update UI
            document.querySelectorAll('.choice-btn').forEach((btn, idx) => {
                btn.classList.toggle('selected', idx === choiceIndex);
                btn.setAttribute('aria-checked', idx === choiceIndex);
            });

            // Save answer
            answers[currentQuestionIndex] = choiceIndex;
            localStorage.setItem('initiationAnswers', JSON.stringify(answers));

            // Enable submit
            submitBtn.disabled = false;
        }

        // ========== HANDLE PUZZLE ICON CYCLE ==========
        function cyclePuzzleIcon(clickedIndex, currentOrder, question) {
            const allIcons = question.correctOrder;
            const currentIcon = currentOrder[clickedIndex];
            const currentIconIndex = allIcons.indexOf(currentIcon);
            const nextIconIndex = (currentIconIndex + 1) % allIcons.length;
            
            currentOrder[clickedIndex] = allIcons[nextIconIndex];

            // Re-render puzzle
            answers[currentQuestionIndex] = [...currentOrder];
            localStorage.setItem('initiationAnswers', JSON.stringify(answers));

            renderQuestion(currentQuestionIndex);

            // Check if correct
            if (JSON.stringify(currentOrder) === JSON.stringify(question.correctOrder)) {
                submitBtn.disabled = false;
            } else {
                submitBtn.disabled = true;
            }
        }

        // ========== UPDATE PROGRESS BAR ==========
        function updateProgress() {
            const answered = answers.filter(a => a !== undefined).length;
            const percentage = (answered / questions.length) * 100;
            progressFill.style.width = `${percentage}%`;
            progressText.textContent = `${answered} / ${questions.length}`;
        }

        // ========== SUBMIT ANSWER ==========
        function submitAnswer() {
            const question = questions[currentQuestionIndex];
            const answer = answers[currentQuestionIndex];

            // Calculate score for this answer
            if (question.type === 'choice') {
                const choice = question.choices[answer];
                scores[choice.role] += choice.weight;
            } else if (question.type === 'puzzle') {
                // Puzzle correct = bonus to ghost (stealth/logic)
                if (JSON.stringify(answer) === JSON.stringify(question.correctOrder)) {
                    scores.ghost += 2;
                }
            }

            // Move to next question or reveal role
            if (currentQuestionIndex < questions.length - 1) {
                currentQuestionIndex++;
                renderQuestion(currentQuestionIndex);
                submitBtn.disabled = true;
            } else {
                revealRole();
            }
        }

        // ========== SKIP QUESTION ==========
        function skipQuestion() {
            if (currentQuestionIndex < questions.length - 1) {
                currentQuestionIndex++;
                renderQuestion(currentQuestionIndex);
                submitBtn.disabled = true;
            } else {
                revealRole();
            }
        }

        // ========== ABORT TEST ==========
        function abortTest() {
            if (confirm('Are you sure you want to abort? All progress will be lost.')) {
                localStorage.removeItem('initiationAnswers');
                window.location.href = 'landing.html';
            }
        }

        // ========== REVEAL ROLE ==========
        function revealRole() {
            // Find highest scoring role
            let assignedRole = 'ghost'; // Default
            let maxScore = scores.ghost;

            if (scores.venom > maxScore) {
                assignedRole = 'venom';
                maxScore = scores.venom;
            }
            if (scores.prophet > maxScore) {
                assignedRole = 'prophet';
                maxScore = scores.prophet;
            }

            // If tie, prefer ghost > venom > prophet
            if (scores.ghost === scores.venom && scores.ghost === scores.prophet) {
                assignedRole = 'ghost';
            } else if (scores.ghost === scores.venom && scores.ghost > scores.prophet) {
                assignedRole = 'ghost';
            } else if (scores.venom === scores.prophet && scores.venom > scores.ghost) {
                assignedRole = 'venom';
            }

            const role = roles[assignedRole];

            // Update modal
            roleIcon.textContent = role.icon;
            roleTitle.textContent = role.title;
            roleDescription.textContent = role.description;

            // Show modal
            roleModal.classList.add('active');
        }

        // ========== ACCEPT ROLE ==========
        function acceptRole() {
            localStorage.removeItem('initiationAnswers');
            alert('Role accepted. Welcome to the Neon Serpents. Redirecting to operations...');
            // In real app, would redirect to dashboard or success page
            window.location.href = 'landing.html';
        }

        // ========== RETRY TEST ==========
        function retryTest() {
            localStorage.removeItem('initiationAnswers');
            window.location.reload();
        }

        // ========== EVENT LISTENERS ==========
        submitBtn.addEventListener('click', submitAnswer);
        skipBtn.addEventListener('click', skipQuestion);
        abortBtn.addEventListener('click', abortTest);
        acceptRoleBtn.addEventListener('click', acceptRole);
        retryBtn.addEventListener('click', retryTest);

        // Keyboard navigation
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !submitBtn.disabled) {
                submitAnswer();
            }
        });

        // ========== INITIALIZE ==========
        renderQuestion(currentQuestionIndex);
    </script>
</body>
</html>
